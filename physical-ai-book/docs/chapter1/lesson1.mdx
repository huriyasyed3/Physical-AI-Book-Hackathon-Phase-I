---
sidebar_position: 2
title: "ROS 2 Architecture: Nodes, Topics, and Services"
---

# Lesson 1: ROS 2 Architecture: Nodes, Topics, and Services

## Overview

This lesson introduces the core architectural concepts of ROS 2: Nodes, Topics, and Services. These form the foundation of the robotic communication system, enabling different components of a robot to communicate and coordinate effectively.

## Learning Objectives

By the end of this lesson, you will be able to:
- Understand the fundamental concepts of ROS 2 architecture
- Create and manage ROS 2 nodes
- Implement topic-based communication between nodes
- Use services for request-response communication
- Understand the differences between topics and services

## What is ROS 2?

ROS 2 (Robot Operating System 2) is not an operating system but rather a middleware framework that provides services designed for a heterogeneous computer cluster. It includes hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. ROS 2 serves as the "nervous system" of a robot, enabling different components to communicate and coordinate.

### Key Components of ROS 2 Architecture

1. **Nodes**: Processes that perform computation. Nodes are the fundamental building blocks of a ROS 2 program.
2. **Topics**: Named buses over which nodes exchange messages. Topics enable asynchronous, many-to-many communication.
3. **Services**: Synchronous request-response communication between nodes. Services enable one-to-one communication with guaranteed delivery.

## ROS 2 Nodes

A node is an executable that uses ROS 2 to communicate with other nodes. Nodes are organized into packages for better modularity and reusability.

### Creating a ROS 2 Node

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Minimal node created')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Node Lifecycle

ROS 2 nodes can have different lifecycle states:
- **Unconfigured**: Node created but not configured
- **Inactive**: Configured but not active
- **Active**: Fully operational
- **Finalized**: Node is shutting down

## Topics and Publishers/Subscribers

Topics enable asynchronous communication between nodes using a publish-subscribe model.

### Publisher Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello World: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.i += 1
```

### Subscriber Example

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')
```

### Topic Communication Characteristics

- **Asynchronous**: Publishers and subscribers don't need to run simultaneously
- **Many-to-many**: Multiple publishers and subscribers can use the same topic
- **Unidirectional**: Data flows from publisher to subscriber
- **Message-based**: Communication happens through serialized messages

## Services

Services provide synchronous request-response communication between nodes.

### Service Server Example

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalService(Node):
    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Returning: {request.a} + {request.b} = {response.sum}')
        return response
```

### Service Client Example

```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts

class MinimalClient(Node):
    def __init__(self):
        super().__init__('minimal_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()
```

### Service Communication Characteristics

- **Synchronous**: Client waits for response from server
- **One-to-one**: Direct communication between client and server
- **Guaranteed delivery**: Request will be processed by server
- **Stateful**: Can maintain state between calls

## Comparison: Topics vs Services

| Aspect | Topics | Services |
|--------|--------|----------|
| Communication Type | Publish-Subscribe | Request-Response |
| Synchronization | Asynchronous | Synchronous |
| Communication Pattern | Many-to-many | One-to-one |
| Delivery Guarantee | No guarantee | Guaranteed |
| Use Case | Sensor data, continuous updates | Actions, computations |

## Quality of Service (QoS) Settings

ROS 2 provides Quality of Service settings to control communication behavior:

```python
from rclpy.qos import QoSProfile, QoSDurabilityPolicy, QoSHistoryPolicy, QoSReliabilityPolicy

# Create a QoS profile
qos_profile = QoSProfile(
    depth=10,
    durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,
    history=QoSHistoryPolicy.KEEP_LAST,
    reliability=QoSReliabilityPolicy.RELIABLE
)

# Use in publisher
publisher = self.create_publisher(String, 'topic', qos_profile)
```

## Hands-on Activity: ROS 2 Communication

1. Create a simple publisher node that publishes sensor data
2. Create a subscriber node that processes the sensor data
3. Create a service server that performs a calculation
4. Create a service client that requests the calculation
5. Run the nodes and observe the communication patterns

## Summary

ROS 2's architecture of Nodes, Topics, and Services provides a robust communication framework for robotic systems. Understanding these concepts is essential for building distributed robotic applications where different components need to communicate effectively.

## Next Steps

In the next lesson, we'll explore how to bridge Python AI agents to ROS controllers using rclpy.